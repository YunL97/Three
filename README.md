# three
* 타입스크립트는 자바스크립트보다 엄격하기 때문에 에러를 더 잘잡는다
* renderer: 3d 장면을 렌더링 해서 화면에 표시하는 역할을 한다
* THREE.WebGLRenderer(): 대부분의 경우 가장 빠르고 가장 많이 지원되는 webgl 렌더러를 사용한다
* OrbitControls: OrbitControls 통해서 3d 장면을 회전하고 확대, 축소 가능
*  THREE.PerspectiveCamera
   *  첫번째인자: 시야 각도
   *  두번째인자: 가로 세로비율
   *  세번째인자: 카메라로부터 시점까지의 가까운 경계, 이값보다 가까이 있는 객체는 렌더링 되지 않음
   *  네번째 인자: 카메라로부터 시점까지의 먼 경계, 이값보다 멀리 있는 객체는 렌더링 되지 않음
* dat.gut 라이브러리: 구글의 엔지니어들이 만든 라이브러리, dat.gui가 생성한 패널 부분에서 매개변수를 변경하면 이미지의 위치, 크기, 회전속도등을 동적으로 반영할수 있도록 한다 -> lil gui로 마이크레이션 되었다. -> three.js 버전안에는 lil gui가 이미 설치되어 있어서 따로 설치하지 않아도 된다
* scene: 3d 공간에서 모든것을 배치하고 관리하는 컨테이너 역할을 한다.
* camera: 보이는 부분을 정의, 3d공간에서 어떤 시점에서 보이는지를 결정
* renderer: 3d객체를 화면에 그리는 역할을 한다. webgl을 기반으로 작동하며 웹브라우저에서 gpu를 사용해서 그래픽을 렌더링한다 -> 고성능의 3d그래픽을 웹 애플리케이션에서 구현 가능
* animation loop: 화면을 지속적으로 업데이트 하여 애니메이션을 만드는 프로세스
  1. 입력갱신: 사용자입력을 감지하고 이를 바탕으로 애니메이션 상태를 업데이트
  2. 상태 업데이트: 애니메이션에 필요한 상태를 업데이트한다. ex) 객체의 위치, 회전, 크기등을 변경하여 다음 프레인의 상태결정
  3. 렌더링: 업데이트된 상태를 기반으로 화면에 3d객체를 렌더링, 이는 카메라의 시점을 적용하고 조명과 재질을 계산하여 실제로 화면에 그래픽을 출력
  4. 반복: 이전 단계를 반복하여 애니메이션 루프를 유지
  5. requestAnimationFrame: 브라우저에게 애니메이션을 수행하고 다음 리페인트를 요청하는 메서드, 모니터 프레임이 120이면 1초에 120번 렌더링될 프레임을준비할수 있도록 지원한다. 브라우저가 비활성화된 탭의 애니메이션을 일시중지하고 전력 소모를 줄이기 위해 최적화된 애니메이션 렌더링을 지원한다
  6. 프레임이 바뀌면 속도가 바뀌므로 코드 설정을 해줘야한다
```
const clock = new THREE.Clock()
let delta = clock.getDelta()
cube.rotation.x += delta
```
* scene.add(new THREE.AxesHelper(5)): 축 폭5짜리 선 추가
* stats panel: 성능 모니터링 및 디버깅 도구
* dat GUI Panel: 웹 기반의 사용자 인터페이스를 생성하기 위한 간단하고 유연한 라이브러리 -> dat.gui는 주로 웹 그래픽 애플리케이션개발에 많이 사용
* object 3D: three.js라이브러리에서 가장 기본적인 3d 객체를 나타내는 클래스 -> 모든 3d 객체의 부모 클래스이며 다양한 종류의 3d 객체를 생성하고 관리하는데 사용
* object 3D hierarchy: 계층구조, 3d 객체를 조직화하고 관리하는 방법을 나타낸다
* Geometries: 3d 객체의  기하학적 모양을 정의하는데 사용되는 클래스 ex) 상자, 구, 별
* material: 3d객체의 외관을 정의하는데 사용되는 클래스 ex) 생상, 텍스처, 광택, 그림자등을 정의 가능
  * MeshBasicMaterial: 가장 기본적인 재질로, 빛의 반사나 그림자를 고려하지 않고 단색 또는 간단한 텍스처를 적용할 수 있습니다.
  * MeshNormalMaterial: 한 법선 벡터를 시각화하여 개발자가 객체의 표면 방향을 확인하고 디버깅하는 데 도움을 줍니다. -> 애플리케이션을 개발중이고 아직 결정하지 않은 경우 메쉬 이반 재질이 정말 좋다
  * MeshLambertMaterial: 빛의 반사를 고려하지만 Phong 재질보다 계산이 덜 복잡한 재질입니다. 부드럽고 광택이 없는 외관을 만들 수 있습니다.
  * MeshPhongMaterial: 빛의 반사를 고려하여 부드러운 그림자와 광택을 생성하는 데 사용됩니다. 피아노 블랙처럼 매끄럽고 광택나는 표면을 만들 수 있습니다.
  * MeshStandardMaterial: PBR(Physically Based Rendering)을 지원하는 재질로, 현실적인 광택과 그림자를 생성할 수 있습니다. PBR이 최근 많은 3d 애플리케이션의 표준이 되었다
  * MeshPhysicalMaterial: 빛의 반사 및 광택, 그림자 등을 현실적으로 시뮬레이션하여 더 자연스러운 외관을 만들 수 있습니다.
  *  MeshMatcapMaterial: 이미지의 빛과 그림자 정보를 사용하여 객체의 표면을 시각화합니다.
  *  MeshToonMaterial: 실적이지 않은 스타일의 렌더링을 만들기 위해 주로 사용

* Specular Map: 3d 그래픽에서 빛의 반사를 제어하기 위해 사용되는 텍스쳐 맵의 한종류 
* Roughness: 재질(material) 의 표면이 얼마나 부드럽거나 거칠게 보이는지를 나타내는 지표
* Metalness Maps: 물체의 표면이 금속적인 속성을 가지고 있는지 여부를 결정하는데 사용되는 텍스쳐맵
* bumpmap: 표면에서 입체적인 디테일을 시뮬레이션 하기 위해 사용되는 텍스쳐 맵
* normalmap: 표면에서 입체적인 디테일을 시뮬레이션 하기 위해 사용되는 텍스쳐 맵 인데, 픽셀당 표면의 노말 벡터의 방향을 나타내어 객체의 표면이 어떻게 조명을 받는지를 결정한다
* Displacement Map: 객체의 표면을 실제로 이동시켜서 입체적인 디테일을 생성하는데 사용되는  텍스처 맥의 한종류
* texture Mipmap: 텍스처를 더 부드럽고 선명하게 표현하기 위한 기술, 텍스터의 해상도를 줄인 버전의 복사본을 만들어내는 기법 -> 멀리 떨어진 곳에서도 부드럽게 보이게 된다
* Anisotropic Filtering: 텍스처를 더 선명하게 표현하기 위한 기술중 하나. 멀리 떨어진 곳에서도 세부적인 디테일을 더 잘 보이도록 만든다
* Ambient Light: 주변에서 발생하는 광원을 나타내는데 사용되는 광원의 한종류
* Directional Light: 특정 방향에서 일정한 강도로 발생하는 광원을 나타내느데 사용되는 광원의 한종류
* Hemisphere Light: 주변에서 발생하는 광원을 나타내는데 모든 방향에서 일정한 강도로 발생하면 전체 씬에 일관된 조명 효과를 부여하는데 사용된다
* point light: 특점 지점에서 모든 방향으로 일정한 강도로 발생하는 광원을 나타내는데 사용
* spot light: 특정 방향으로 집중된 광원을 생성하며 특정지점에서 발생해서 특정방향으로 빛을 쏘아올리는 형태
* OBJ Model Loader: three.js 와 같은 3d 그래픽 라이브러리에서 사용되는 모델로더이다. object 파일 형식의 3d모댈을 로드하여 웹 애플리케이션에 표시하는데 사용된다
* OBJ 파일: 정점, 면, 텍스처 및 재질정보를 포함하는 텍스트 파일 형식의 3d 모델을 나타낸다
```
 const objLoader = new ObJLoader()
 objLoader.load(
  'models/cube.obj',
  (object) => {
    scene.add(object)
  }, 
  (xhr) => {
    console.log((xh4.loaded / xhr.total) * 100 + '% loaded') //로드율 확인할떄 효율적
  }
 )
```
* MTL Loader: OBJ 파일과 함께 사용되며 각각의 재질에 대한 정보를 포함한다.재질의 색상, 텍스처 맵, 광택, 반사율 등이 포함될 수 있다
* GLTF Model Loader: json 기반의 포맷, 효율적이고 압축된 텍스처 및 기하 정보를 지원하며 애니메이션 및 재질 정보를 포함 가능 또한 여러개의 모델 및 재질을 하나의 파일로 결합 가능
* GLB: GLTF는 json기반으로 파일크기가 커질수 있고 로드 및 파싱 기간이 길어질수 있음 -> glTF Binary(GLB) 이진 형식으로 변화해서 더 효율적인 파일 형식을 제공
* GLB 이 GLTF 파일보다 크기가 작아서 GLB를 더 선호한다
* DRACO Loader: DRACO는 giigkle에서 개발한 압축 알고리즘으로 3d 모델의 기하 정보를 효율적으로 압축하여 저장할 수 있다. 이를 통해  모델 파일의 크기를 줄이고 로드 시간 단축 가능, DRACO LOADER 은 DRACO 압축 형식으로 압축된 3d 모델을 로드하고 디코딩해서 three.js 에서 사용할 수 있는ㄴ 형식을 변환한다 -> 압축이 되어서 크기는 줄지만 디코딩이 오래걸리기 때문에 현실에서는 많이 사용하지 않는다
* cdn(Content Delivery Network): 웹 컨텐츠를 사용자에게 효율적으로 전달하기위해 사용되는 분산 네트워크 -> 이미지, 스크립트, 스타일시트 등의 복사본을 저장하고 있고 사용자의 요청에 ㄲ따라 가장 가까운 서버에서 해당 콘텐츠를 제공
* HDR(high dynamic range): 가장 밝은곳부터 가장 어두운곳 까지 눈으로 직접 보는것과 최대한 가깝게 밝기의 범위를 확장하는 기술
* Raycaster: 3d 그래픽에서 레이캐스팅을 수행하는 객체, 레이캐스팅은 가상의 광선을 특정방향으로 발사하여 그 광선이 교차하는 3d 공간의 객체를 검출하는 기술
* lerp: 선형보간, 두 점 사이의 직선을 따라 값을 보간(두값 사이의 중간값을 계산하는 과정)하는 방법 -> ex) 두 프레임 사이를 보간 하여 부드러운 애니메이션을 만드는 데 사용가능 or 색상값, 위치값등을 보간하는데에도 사용