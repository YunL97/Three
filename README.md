# three
* 타입스크립트는 자바스크립트보다 엄격하기 때문에 에러를 더 잘잡는다
* THREE.WebGLRenderer(): 대부분의 경우 가장 빠르고 가장 많이 지원되는 webgl 렌더러를 사용한다
*  THREE.PerspectiveCamera
   *  첫번째인자: 시야 각도
   *  두번째인자: 가로 세로비율
   *  세번째인자: 카메라로부터 시점까지의 가까운 경계, 이값보다 가까이 있는 객체는 렌더링 되지 않음
   *  네번째 인자: 카메라로부터 시점까지의 먼 경계, 이값보다 멀리 있는 객체는 렌더링 되지 않음
* dat.gut 라이브러리: 구글의 엔지니어들이 만든 라이브러리, dat.gui가 생성한 패널 부분에서 매개변수를 변경하면 이미지의 위치, 크기, 회전속도등을 동적으로 반영할수 있도록 한다
* scene: 3d 공간에서 모든것을 배치하고 관리하는 컨테이너 역할을 한다.
* camera: 보이는 부분을 정의, 3d공간에서 어떤 시점에서 보이는지를 결정
* renderer: 3d객체를 화면에 그리는 역할을 한다. webgl을 기반으로 작동하며 웹브라우저에서 gpu를 사용해서 그래픽을 렌더링한다 -> 고성능의 3d그래픽을 웹 애플리케이션에서 구현 가능
* animation loop: 화면을 지속적으로 업데이트 하여 애니메이션을 만드는 프로세스
  1. 입력갱신: 사용자입력을 감지하고 이를 바탕으로 애니메이션 상태를 업데이트
  2. 상태 업데이트: 애니메이션에 필요한 상태를 업데이트한다. ex) 객체의 위치, 회전, 크기등을 변경하여 다음 프레인의 상태결정
  3. 렌더링: 업데이트된 상태를 기반으로 화면에 3d객체를 렌더링, 이는 카메라의 시점을 적용하고 조명과 재질을 계산하여 실제로 화면에 그래픽을 출력
  4. 반복: 이전 단계를 반복하여 애니메이션 루프를 유지

* stats panel: 성능 모니터링 및 디버깅 도구
* dat GUI Panel: 웹 기반의 사용자 인터페이스를 생성하기 위한 간단하고 유연한 라이브러리 -> dat.gui는 주로 웹 그래픽 애플리케이션개발에 많이 사용
* object 3D: three.js라이브러리에서 가장 기본적인 3d 객체를 나타내는 클래스 -> 모든 3d 객체의 부모 클래스이며 다양한 종류의 3d 객체를 생성하고 관리하는데 사용
* object 3D hierarchy: 계층구조, 3d 객체를 조직화하고 관리하는 방법을 나타낸다
* Geometries: 3d 객체의  기하학적 모양을 정의하는데 사용되는 클래스
* material: 3d객체의 외관을 정의하는데 사용되는 클래스 ex) 생상, 텍스처, 광택, 그림자등을 정의 가능
  * MeshBasicMaterial: 가장 기본적인 재질로, 빛의 반사나 그림자를 고려하지 않고 단색 또는 간단한 텍스처를 적용할 수 있습니다.
  * MeshNormalMaterial: 한 법선 벡터를 시각화하여 개발자가 객체의 표면 방향을 확인하고 디버깅하는 데 도움을 줍니다.
  * MeshLambertMaterial: 빛의 반사를 고려하지만 Phong 재질보다 계산이 덜 복잡한 재질입니다. 부드럽고 광택이 없는 외관을 만들 수 있습니다.
  * MeshPhongMaterial: 빛의 반사를 고려하여 부드러운 그림자와 광택을 생성하는 데 사용됩니다. 피아노 블랙처럼 매끄럽고 광택나는 표면을 만들 수 있습니다.
  * MeshStandardMaterial: PBR(Physically Based Rendering)을 지원하는 재질로, 현실적인 광택과 그림자를 생성할 수 있습니다.
  * MeshPhysicalMaterial: 빛의 반사 및 광택, 그림자 등을 현실적으로 시뮬레이션하여 더 자연스러운 외관을 만들 수 있습니다.
  *  MeshMatcapMaterial: 이미지의 빛과 그림자 정보를 사용하여 객체의 표면을 시각화합니다.
  *  MeshToonMaterial: 실적이지 않은 스타일의 렌더링을 만들기 위해 주로 사용

* Specular Map: 3d 그래픽에서 빛의 반사를 제어하기 위해 사용되는 텍스쳐 맵의 한종류 
* Roughness: 재질(material) 의 표면이 얼마나 부드럽거나 거칠게 보이는지를 나타내는 지표
* Metalness Maps: 물체의 표면이 금속적인 속성을 가지고 있는지 여부를 결정하는데 사용되는 텍스쳐맵
* bumpmap: 표면에서 입체적인 디테일을 시뮬레이션 하기 위해 사용되는 텍스쳐 맵
* normalmap: 표면에서 입체적인 디테일을 시뮬레이션 하기 위해 사용되는 텍스쳐 맵 인데, 픽셀당 표면의 노말 벡터의 방향을 나타내어 객체의 표면이 어떻게 조명을 받는지를 결정한다
* Displacement Map: 객체의 표면을 실제로 이동시켜서 입체적인 디테일을 생성하는데 사용되는  텍스처 맥의 한종류
* texture Mipmap: 텍스처를 더 부드럽고 선명하게 표현하기 위한 기술, 텍스터의 해상도를 줄인 버전의 복사본을 만들어내는 기법 -> 멀리 떨어진 곳에서도 부드럽게 보이게 된다
* Anisotropic Filtering: 텍스처를 더 선명하게 표현하기 위한 기술중 하나. 멀리 떨어진 곳에서도 세부적인 디테일을 더 잘 보이도록 만든다
* Ambient Light: 주변에서 발생하는 광원을 나타내는데 사용되는 광원의 한종류
* Directional Light: 특정 방향에서 일정한 강도로 발생하는 광원을 나타내느데 사용되는 광원의 한종류
* Hemisphere Light: 주변에서 발생하는 광원을 나타내는데 모든 방향에서 일정한 강도로 발생하면 전체 씬에 일관된 조명 효과를 부여하는데 사용된다
* point light: 특점 지점에서 모든 방향으로 일정한 강도로 발생하는 광원을 나타내는데 사용
* spot light: 특정 방향으로 집중된 광원을 생성하며 특정지점에서 발생해서 특정방향으로 빛을 쏘아올리는 형태
* OBJ Model Loader: three.js 와 같은 3d 그래픽 라이브러리에서 사용되는 모델로더이다. object 파일 형식의 3d모댈을 로드하여 웹 애플리케이션에 표시하는데 사용된다
* OBJ 파일: 정점, 면, 텍스처 및 재질정보를 포함하는 텍스트 파일 형식의 3d 모델을 나타낸다
```
 const objLoader = new ObJLoader()
 objLoader.load(
  'models/cube.obj',
  (object) => {
    scene.add(object)
  },
  (xhr) => {
    console.log((xh4.loaded / xhr.total) * 100 + '% loaded') //로드율 확인할떄 효율적
  }
 )
```
* MTL Loader: OBJ 파일과 함께 사용되며 각각의 재질에 대한 정보를 포함한다.재질의 색상, 텍스처 맵, 광택, 반사율 등이 포함될 수 있다
* GLTF Model Loader: json 기반의 포맷, 효율적이고 압축된 텍스처 및 기하 정보를 지원하며 애니메이션 및 재질 정보를 포함 가능 또한 여러개의 모델 및 재질을 하나의 파일로 결합 가능
* GLB: GLTF는 json기반으로 파일크기가 커질수 있고 로드 및 파싱 기간이 길어질수 있음 -> glTF Binary(GLB) 이진 형식으로 변화해서 더 효율적인 파일 형식을 제공
* GLB 이 GLTF 파일보다 크기가 작아서 GLB를 더 선호한다
* DRACO Loader: DRACO는 giigkle에서 개발한 압축 알고리즘으로 3d 모델의 기하 정보를 효율적으로 압축하여 저장할 수 있다. 이를 통해  모델 파일의 크기를 줄이고 로드 시간 단축 가능, DRACO LOADER 은 DRACO 압축 형식으로 압축된 3d 모델을 로드하고 디코딩해서 three.js 에서 사용할 수 있는ㄴ 형식을 변환한다 -> 압축이 되어서 크기는 줄지만 디코딩이 오래걸리기 때문에 현실에서는 많이 사용하지 않는다
* 